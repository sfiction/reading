## Chapter 1 UNIX 基础知识

### 1.2 UNIX 体系结构

- 内核（Kernel）
- shell，公用函数库
- 应用程序

### 1.3 登录

口令文件 `/etc/passwd` 中 7 个用冒号分隔的字段：登录名、加密口令、数字用户 ID、数字组 ID、注释字段、起始目录、shell 程序。其中加密口令已经被移到其他文件，实验发现这一字段实际均为“x”。

### 1.4 文件和目录

根目录 `/`。

文件名不能包含斜线和空字符。但为了使用方便，一般限制为大小写英文字母、数字、点、短横、下划线。`.` 和 `..` 是当前目录和上级目录。

每个进程都有一个工作目录。

### 1.5 输入和输出

文件描述符通常是一个小的非负整数，标识一个特定进程正在访问的文件。

shell 为新程序打开 stdin/out/err 三个文件描述符。

无缓冲的 I/O 方法、标准 I/O。

### 1.6 程序和进程

程序是磁盘上的可执行文件，内核用 `exec` 族的函数将其读入内存并运行。

程序的执行实例为进程，有唯一的标识符进程 ID。`long getpid();`

进程控制：fork、exec、waitpid。

### 1.7 出错处理

UNIX 系统函数出错时会返回一个负值，并设置全局整型变量 `errno`。也有函数约定了其他方式，如返回 null 指针表示错误。

`errno` 的可选值定义在 `errno.h` 中。多线程环境中为避免对 `errno` 的修改相互干扰，用一个支持多线程的函数代替了整型变量。`char *strerror(int enum)` 返回对应的错误信息，`void perror(const char *msg)` 在标准错误上打印信息 `<msg>:<errno_msg> `。

致命性出错、非致命出错和出错恢复。

### 1.8 用户标识

用户 ID 和组 ID，由系统分配的数值。

附属组 ID，用户可以同时属于原有用户组以外的组。

### 1.9 信号

- 忽略信号
- 按系统默认方式处理
- 提供一个函数来处理，用 `signal` 函数添加

### 1.10 时间值

- 日历时间：1970.01.01 00:00:00 以来秒数
- 进程时间：用时钟滴答数计算

进程的执行时间：

- wall clock time
- 用户 CPU 时间
- 系统 CPU 时间

后两者是用户态和系统态下的运行时间

### 1.11 系统调用和库函数

系统调用：内核的入口点

UNIX 为每个系统调用在标准 C 库中实现一个同名函数，函数根据系统要求调用相应的内核服务。在应用看来，可以将系统调用视为 C 函数。

系统调用和库函数处在不同的抽象层级上。如应用程序、`malloc`、`sbrk` 之间的关系。

系统调用通常提供最小接口，库函数则提供相对复杂的功能。

## Chapter 2 UNIX 标准及实现

- ISO C
- Portable Operating System Interface (POSIX)
- Single UNIX Specification (SUS)

### 2.5 限制

- 编译时：头文件
- 与文件或目录无关的运行时：sysconf 函数
- 与文件或目录有关的运行时：pathconf, fpathconf 函数。一个猜测：目录和文件系统有关，不同文件系统有不同限制。

#### 2.5.1 ISO C 限制

- 基本类型相关：`limits.h`
- 标准 I/O 流数量：`stdio.h: FOPEN_MAX`
- tmpnam？？：`stdio.h: TMP_MAX`

#### 2.5.2 POSIX 限制

7 类：数值限制、最小值、最大值、运行时可增加、运行时不变、其他不变值、路径名可变值

#### 2.5.5 不确定的运行时限制

例：路径名、最大打开文件数

### 2.6 选项

限制都是数值方面的上下界，选项则是对某项功能支持与否。

### 2.7 功能测试宏

仅保留与某个标准中定义的功能，排除特定实现在标准外的定义，如 `_POSIX_C_SOURCE`。

### 2.8 基本系统数据类型

图 2-21，常用的基本系统数据类型。有印象的有 `clock_t`, `pthread_t`, `size_t`。

### 2.9 标准之间的冲突

- ISO C 中的 `clock()` 和 POSIX 的 `sysconf`

## Chapter 3 文件 I/O

### 3.2 文件描述符

文件描述符 0/1/2 关联到 stdin/out/err 是 shell 的各种实现和许多应用程序的惯例，与内核无关。在 POSIX.1 中已经标准化，但建议用 `(STDIN|STDOUT|STDERR)_FILENO` 代替来提高可读性。

### 3.3 函数 `open` 和 `openat`

返回文件描述符，失败返回 -1。

`oflag` 参数居然有这么多，有印象的只有 `RDONLY`, `WRONLY`, `RDWR`, `APPEND`, `CREAT`, `TRUNC`。

`openat` 的第一个参数 `dirfd` 仅在 `path` 是相对地址时有效。`dirfd` 取 `AT_FDCWD` 时使用当前进程的工作目录，此时行为与 `open` 相同。

`open` 和 `openat` 返回的文件描述符必定是最小的未使用数值。

##### 文件名和路径名截断

常量 `_POSIX_NO_TRUNC` 决定这一行为，用 `fpathconf` 或 `pathconf` 检查。

### 3.4 函数 `creat`

早期 UNIX 版本中 `open` 的参数有限制，必须用 `creat` 创建新文件。现在 `open` 增加了 `O_CREAT` 和 `O_TRUNC`，不再需要 `creat`。

### 3.5 函数 `close`

关闭文件描述符，并释放当前进程在文件上的所有记录锁（14.3）。

### 3.6 函数 `lseek`

文件偏移量按字节计算，读写操作都会使其增加。偏移量一般为 0，除非打开文件时指定了 `O_APPEND`。

返回新的文件偏移量。

`whence` 参数可选 `SEEK_(SET|CUR|END)`，分别将基准位置取为文件开头、当前位置、文件长度。

某些设备支持负的偏移量，因此检查返回值时应该测试是否等于 -1。

可以用 `lseek` 创建带“空洞”的文件。空洞部分不占用磁盘块。

### 3.7 函数 `read`

返回读取字节数。

在很多情况下，读到的字节数会少于参数指定要读的字节数。

### 3.8 函数 `write`

返回写入字节数。

### 3.9 I/O 的效率

### 3.10 文件共享

- 操作系统维护一个进程表
- 进程表中属于某个进程的记录项包含一个打开文件描述符表
  - 打开文件描述符表中的每一项包含文件描述符的 flag，以及指向系统文件表中对应项的指针
- 操作系统维护一个打开文件表
  - 每一项包含文件状态、文件偏移量、指向该文件 v-node 表中对应项的指针
- 每个打开文件都有一个 v-node 结构，包含文件的相关信息，如文件长度、所有者

容易想到多个文件表项指向同一个 v-node 节点表项的情形，即多个进程分别打开了同一个文件。多个文件描述符项指向同一个文件表项的情形同样可能出现（3.12）。

### 3.11 原子操作

对没有 `O_APPEND` 标志的打开文件，要进行追加写时需要先使用 `lseek` 定位再写入，并发时可能会引起问题。有 `O_APPEND` 标志的打开文件则是在 `write` 时（在内核态）设置偏移量，可以视为原子操作。

`pread` 和 `pwrite`，相比普通的文件读写系统调用多了一个 `off_t offset` 参数，可以指定文件偏移量。

`open` 函数的 `O_CREAT` 和 `O_EXCL` 选项同时开启使得检查文件是否存在和创建文件合为一个原子操作。

### 3.12 函数 `dup` 和 `dup2`

都用于复制一个现有的文件描述符。`dup` 返回的新文件描述符是最小的可用值，`dup2` 则由调用者指定。复制后两个文件描述符指向文件表中的同一个文件表项。

### 3.13 函数 `sync`、`fsync` 和 `fdatasync`

用于将所有延迟写的缓冲块同步到磁盘。

- `sync`， 只将块排入队列，即时返回
- `fsync`, 等待写操作结束后返回，且只对指定的文件描述符生效
- `fdatasync`, 类似 `fsync`，但只影响文件的数据部分

### 3.14 函数 `fcntl`

改变已经打开的文件的属性。
- 复制已有描述符
- get/set 文件描述符标志
- get/set 文件状态标志
- get/set 异步 I/O 所有权
- get/set 记录锁

一个应用：设置 O_SYNC 同步写标志。

### 3.15 函数 `ioctl`

I/O 方面的杂物箱

### 3.16 `/dev/fd`

对进程来说，打开 `/dev/fd/n` 等价于 `dup(n)`（Linux 中略有差异），因此可以令一些以路径名为命令行参数的程序，以处理普通文件的方式处理标准输入输出。很多程序是用 '-' 来指示标准输入的。

## Chpater 4 文件和目录

### 4.2 函数 `stat`、`fstat`、`fstatat` 和 `lstat`

```c
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf );
int fstat(int fd, struct stat *buf );
int lstat(const char *restrict pathname, struct stat *restrict buf );
int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
All four return: 0 if OK, −1 on error
```

`lstat` 相比 `stat` 会返回符号链接本身的信息，`fstatat` 则可以通过 `flag` 控制。

### 4.3 文件类型

- 普通文件, 二进制与文本并无区别，全由处理文件的程序决定
  - 二进制可执行文件需要遵循标准化格式
- 目录文件
- 块特殊文件, 对设备带缓冲的访问，定长
- 字符特殊文件, 对设备不带缓冲的访问，每次访问长度可变
- FIFO, 用于进程间通信
- 套接字
- 符号链接

用 `sys/stat.h` 中的文件类型宏确定文件类型，参数是 `struct stat` 的 `st_mode` 成员。（图 4.1）

### 4.4 设置用户 ID 和设置组 ID

（实际|有效）（用户|组）ID、附属组 ID、保存的设置（用户|组）ID。

最后这两个是什么……（8.11 节）

会话期间实际 ID 通常不会发生改变，但超级用户进程有办法修改这些值。

执行程序时，进程的有效 ID 通常就是实际 ID。但可以在文件模式字（`st_mode`）中设置一个特殊标志，使得有效用户 ID 是所有者的用户 ID。例如 `passwd`。

### 4.5 文件访问权限





















